# Zsh configuration generated by dotfiles


# Path to oh-my-zsh installation
export ZSH="$HOME/.oh-my-zsh"

# Add zsh-completions to fpath before oh-my-zsh loads
if [[ -d "$HOME/.oh-my-zsh/custom/plugins/zsh-completions/src" ]]; then
    fpath=($HOME/.oh-my-zsh/custom/plugins/zsh-completions/src $fpath)
fi

# Add Homebrew completions to fpath
if [[ -d "/opt/homebrew/share/zsh/site-functions" ]]; then
    fpath=(/opt/homebrew/share/zsh/site-functions $fpath)
elif [[ -d "/usr/local/share/zsh/site-functions" ]]; then
    fpath=(/usr/local/share/zsh/site-functions $fpath)
fi

# Theme
ZSH_THEME="powerlevel10k/powerlevel10k"

# Plugins - Essential only, add more as needed
plugins=(
    git
    zsh-autosuggestions
    zsh-syntax-highlighting
    zsh-completions
    docker
    sudo
    history-substring-search
    colored-man-pages
)

# Load Oh My Zsh
source $ZSH/oh-my-zsh.sh

# User configuration

# Environment variables
export EDITOR='nvim'
export VISUAL='nvim'
export PAGER='less'
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8
export TERM=xterm-256color

# History configuration
HISTSIZE=50000
SAVEHIST=50000
setopt EXTENDED_HISTORY
setopt SHARE_HISTORY
setopt APPEND_HISTORY
setopt INC_APPEND_HISTORY
setopt HIST_EXPIRE_DUPS_FIRST
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_FIND_NO_DUPS
setopt HIST_IGNORE_SPACE
setopt HIST_SAVE_NO_DUPS

# Directory navigation
setopt AUTO_CD
setopt AUTO_PUSHD
setopt PUSHD_IGNORE_DUPS
setopt PUSHD_SILENT

# Completion
autoload -Uz compinit
# Ignore insecure directories and suppress errors from broken symlinks
compinit -i 2>/dev/null || compinit -u
setopt COMPLETE_ALIASES
setopt GLOB_COMPLETE
setopt MENU_COMPLETE
zstyle ':completion:*' menu select
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'

# Key bindings
bindkey '^[[A' history-substring-search-up
bindkey '^[[B' history-substring-search-down
bindkey '^R' history-incremental-search-backward

# Aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

# Modern CLI tool aliases
if command -v eza >/dev/null 2>&1; then
    alias ls='eza'
    alias ll='eza -la'
    alias tree='eza --tree'
fi

if command -v bat >/dev/null 2>&1; then
    alias cat='bat'
    export MANPAGER="sh -c 'col -bx | bat -l man -p'"
fi

if command -v rg >/dev/null 2>&1; then
    alias grep='rg'
fi

if command -v fd >/dev/null 2>&1; then
    alias find='fd'
fi

# Git aliases
alias g='git'
alias ga='git add'
alias gc='git commit'
alias gco='git checkout'
alias gd='git diff'
alias gl='git log --oneline --graph'
alias gp='git push'
alias gs='git status'

# Docker aliases
alias d='docker'
alias dc='docker-compose'
alias dps='docker ps'
alias di='docker images'

# Kubernetes aliases
alias k='kubectl'
alias kgp='kubectl get pods'
alias kgs='kubectl get services'
alias kgd='kubectl get deployments'

# System aliases
alias h='history'
alias c='clear'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias ~='cd ~'

# Network aliases
alias ping='ping -c 5'
alias ports='netstat -tulanp'

# Process aliases
alias psa='ps aux'
alias psg='ps aux | grep'

# Development aliases
alias py='python3'
alias pip='pip3'
alias serve='python3 -m http.server'
alias json='python3 -m json.tool'

# Editor aliases (if neovim is available)
if command -v nvim >/dev/null 2>&1; then
    alias vim='nvim'
    alias vi='nvim'
    alias vimdiff='nvim -d'
fi

# Custom functions
mkcd() {
    mkdir -p "$1" && cd "$1"
}

extract() {
    if [ -f $1 ]; then
        case $1 in
            *.tar.bz2)   tar xjf $1     ;;
            *.tar.gz)    tar xzf $1     ;;
            *.bz2)       bunzip2 $1     ;;
            *.rar)       unrar x $1     ;;
            *.gz)        gunzip $1      ;;
            *.tar)       tar xf $1      ;;
            *.tbz2)      tar xjf $1     ;;
            *.tgz)       tar xzf $1     ;;
            *.zip)       unzip $1       ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1        ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# NVM configuration
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

# Source NVM if installed
if [ -s "$NVM_DIR/nvm.sh" ]; then
    source "$NVM_DIR/nvm.sh"
fi

# Load additional configurations
[ -f ~/.zsh_local ] && source ~/.zsh_local
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# Disable Powerlevel10k configuration wizard
typeset -g POWERLEVEL9K_DISABLE_CONFIGURATION_WIZARD=true

# Powerlevel10k instant prompt
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Load p10k configuration if it exists
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# Terminal title configuration for kitty (user@hostname(IP) - cmd format)
function get_local_ip() {
    # Try different methods to get IP address
    local ip=""
    
    # Method 1: hostname -I (Linux)
    if command -v hostname >/dev/null 2>&1; then
        ip=$(hostname -I 2>/dev/null | awk '{print $1}')
    fi
    
    # Method 2: ip route (Linux)
    if [[ -z "$ip" ]] && command -v ip >/dev/null 2>&1; then
        ip=$(ip route get 1.1.1.1 2>/dev/null | awk '{print $7; exit}')
    fi
    
    # Method 3: ifconfig (macOS/BSD)
    if [[ -z "$ip" ]] && command -v ifconfig >/dev/null 2>&1; then
        ip=$(ifconfig | grep 'inet ' | grep -v '127.0.0.1' | head -1 | awk '{print $2}')
    fi
    
    # Method 4: networksetup (macOS)
    if [[ -z "$ip" ]] && command -v networksetup >/dev/null 2>&1; then
        local service=$(networksetup -listnetworkserviceorder | grep -E '^\([0-9]+\)' | head -1 | sed 's/^([0-9]*) //')
        if [[ -n "$service" ]]; then
            ip=$(networksetup -getinfo "$service" 2>/dev/null | grep '^IP address:' | cut -d' ' -f3)
        fi
    fi
    
    # Fallback: external IP (slower)
    if [[ -z "$ip" ]]; then
        ip=$(curl -s --max-time 2 ifconfig.me 2>/dev/null || echo "no-ip")
    fi
    
    echo "${ip:-no-ip}"
}

function set_terminal_title() {
    if [[ -n "$KITTY_WINDOW_ID" ]]; then
        # Cache IP address to avoid repeated lookups
        if [[ -z "$_CACHED_IP" ]]; then
            _CACHED_IP=$(get_local_ip)
        fi
        
        local hostname="${HOSTNAME:-$(hostname -s 2>/dev/null || echo 'localhost')}"
        local current_dir=$(basename "$PWD")
        local cmd_part=""
        
        if [[ -n "$1" && "$1" != "shell" ]]; then
            # Extract just the command name, not full arguments
            local cmd_name=$(echo "$1" | awk '{print $1}')
            cmd_part=" - $cmd_name"
        fi
        
        # Set title format: user@hostname(IP) - command (if running)
        printf '\033]0;%s@%s(%s)%s\007' "$USER" "$hostname" "$_CACHED_IP" "$cmd_part"
    fi
}

# Set title before each command (zsh preexec hook)
if [[ -n "$KITTY_WINDOW_ID" ]]; then
    autoload -Uz add-zsh-hook
    
    function preexec_set_title() {
        set_terminal_title "$1"
    }
    
    function precmd_set_title() {
        # Reset to base title (no command) when prompt returns
        set_terminal_title ""
    }
    
    add-zsh-hook preexec preexec_set_title
    add-zsh-hook precmd precmd_set_title
    
    # Set initial title
    set_terminal_title ""
    
    # Function to refresh cached IP address
    function refresh_kitty_ip() {
        unset _CACHED_IP
        _CACHED_IP=$(get_local_ip)
        set_terminal_title ""
        echo "Kitty title IP refreshed: $_CACHED_IP"
    }
fi

# Poetry completions
fpath+=~/.zfunc

# Python development aliases
source '/Users/alamin/.dotfiles_python_aliases'

# Go Configuration
export GOPATH="$HOME/go"
export GOROOT="/usr/local/go"
export PATH="$GOROOT/bin:$GOPATH/bin:$PATH"

# Go module proxy (for faster downloads)
export GOPROXY="https://proxy.golang.org,direct"
export GOSUMDB="sum.golang.org"

# Go development settings
export GO111MODULE=on
export CGO_ENABLED=1
export PATH="/usr/local/bin:$PATH"

# Claude API configuration
# Set your Anthropic API key as environment variable:
# export ANTHROPIC_API_KEY="your-api-key-here"

