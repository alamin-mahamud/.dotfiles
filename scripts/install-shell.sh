#!/bin/bash

# Shell Configuration Installation Script
# Installs and configures Zsh, Oh My Zsh, and Tmux

set -euo pipefail

# Detect operating system and set environment variables
detect_environment() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        DOTFILES_OS="macos"
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        DOTFILES_OS="linux"
    else
        DOTFILES_OS="unknown"
        echo "Warning: Unsupported operating system"
    fi
    export DOTFILES_OS
}

# Utility functions for colored output
print_status() {
    echo -e "\033[1;34m[INFO]\033[0m $1"
}

print_success() {
    echo -e "\033[1;32m[SUCCESS]\033[0m $1"
}

print_warning() {
    echo -e "\033[1;33m[WARNING]\033[0m $1"
}

print_error() {
    echo -e "\033[1;31m[ERROR]\033[0m $1"
}

# Initialize environment
detect_environment

# Install Zsh
install_zsh() {
    print_status "Installing Zsh..."

    case "$DOTFILES_OS" in
        linux)
            sudo apt-get update
            sudo apt-get install -y zsh
            ;;
        macos)
            brew install zsh
            ;;
    esac

    print_success "Zsh installed"
}

# Install Oh My Zsh
install_oh_my_zsh() {
    print_status "Installing Oh My Zsh..."

    if [[ -d "$HOME/.oh-my-zsh" ]]; then
        print_status "Oh My Zsh is already installed"
    else
        # Install Oh My Zsh without switching shell yet
        sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended
        print_success "Oh My Zsh installed"
    fi
}

# Install Zsh plugins
install_zsh_plugins() {
    print_status "Installing Zsh plugins..."

    # zsh-autosuggestions
    if [[ ! -d "${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/zsh-autosuggestions" ]]; then
        git clone https://github.com/zsh-users/zsh-autosuggestions \
            "${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/zsh-autosuggestions"
    fi

    # zsh-syntax-highlighting
    if [[ ! -d "${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting" ]]; then
        git clone https://github.com/zsh-users/zsh-syntax-highlighting \
            "${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting"
    fi

    # zsh-completions
    if [[ ! -d "${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/zsh-completions" ]]; then
        git clone https://github.com/zsh-users/zsh-completions \
            "${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/zsh-completions"
    fi

    # fzf-tab (must be loaded after compinit, as last plugin)
    if [[ ! -d "${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/fzf-tab" ]]; then
        git clone https://github.com/Aloxaf/fzf-tab \
            "${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/fzf-tab"
    fi

    print_success "Zsh plugins installed"
}

# Install Powerlevel10k theme
install_powerlevel10k() {
    print_status "Installing Powerlevel10k theme..."

    if [[ ! -d "${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k" ]]; then
        git clone --depth=1 https://github.com/romkatv/powerlevel10k.git \
            "${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k"
    fi

    print_success "Powerlevel10k installed"
}

# Configure Zsh
configure_zsh() {
    print_status "Configuring Zsh..."

    # Backup existing .zshrc
    if [[ -f "$HOME/.zshrc" ]] && [[ ! -L "$HOME/.zshrc" ]]; then
        mv "$HOME/.zshrc" "$HOME/.zshrc.backup"
    fi

    # Create the main .zshrc file with embedded configuration
    cat > "$HOME/.zshrc" << 'ZSHRC_EOF'
# Main .zshrc configuration - Generated by install-shell.sh

# System checks (embedded from checks.zsh)
if [[ $(uname) = 'Linux' ]]; then
    IS_LINUX=1
fi

if [[ $(uname) = 'Darwin' ]]; then
    IS_MAC=1
fi

if [[ -x `which brew` ]]; then
    HAS_BREW=1
fi

if [[ -x `which apt-get` ]]; then
    HAS_APT=1
fi

if [[ -x `which yum` ]]; then
    HAS_YUM=1
fi

# Exports (embedded from exports.zsh)
export LANG=en_US.UTF-8
export TERM=xterm-256color
export EDITOR=vim
export VISUAL=vim

# Paths for golang
export PATH=$PATH:/usr/local/go/bin

# History configuration (embedded from history.zsh)
HISTSIZE=10000
SAVEHIST=9000
HISTFILE=~/.zsh_history

# Oh My Zsh configuration (embedded from omz.zsh)
ZSH=$HOME/.oh-my-zsh
export ZSH_THEME="powerlevel10k/powerlevel10k"

# Note: fzf-tab must be the last plugin to properly bind Tab key
export plugins=(
  git
  docker
  redis-cli
  zsh-autosuggestions
  zsh-syntax-highlighting
  zsh-completions
  fzf-tab
)

source $ZSH/oh-my-zsh.sh

# Python environment configuration (embedded from python.zsh)
export PYENV_ROOT="$HOME/.pyenv"
[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
if command -v pyenv >/dev/null 2>&1; then
    eval "$(pyenv init --path)"
    eval "$(pyenv init -)"
fi

export PATH="$HOME/.local/bin:$PATH"
export PIPENV_PYTHON="$HOME/.pyenv/shims/python"

# Aliases (embedded from aliases.zsh)
alias vim='nvim'
alias asp='export AWS_PROFILE=sandbox-poweruser && aws sso login --profile sandbox-poweruser'
alias asa='export AWS_PROFILE=sandbox-admin && aws sso login --profile sandbox-admin'

# Enable kubectl completion if available
if command -v kubectl >/dev/null 2>&1; then
    source <(kubectl completion zsh)
fi

# Tmux aliases
alias tm='tmux'
alias tma='tmux attach-session -t'
alias tmn='tmux new-session -s'
alias tml='tmux list-sessions'
alias tmk='tmux kill-session -t'
alias tmks='tmux kill-server'
alias tms='tmux-sessionizer'
alias tmp='tmux-project-manager'

# NVM configuration
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"

# FZF integration
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# Z directory jumping
[ -f ~/.z.sh ] && source ~/.z.sh

# ============================================================================
# fzf-tab configuration - Enhanced Tab Completion with FZF
# ============================================================================
#
# USAGE EXAMPLES:
# --------------
# Basic Navigation:
#   cd <TAB>           - Browse directories with preview
#   ls <TAB>           - Browse files with content preview
#   vim <TAB>          - Open files with preview
#
# Git Commands:
#   git checkout <TAB> - Switch branches with commit preview
#   git add <TAB>      - Stage files with diff preview
#   git diff <TAB>     - View diffs with preview
#   git log <TAB>      - Browse commits with details
#
# Process Management:
#   kill <TAB>         - Select process with command preview
#   ps aux | grep <TAB>- Filter processes
#
# System Commands:
#   systemctl <TAB>    - Manage services with status preview
#   ssh <TAB>          - Connect to hosts from history
#   docker <TAB>       - Manage containers/images
#
# KEY BINDINGS:
# ------------
#   TAB / Shift-TAB   - Navigate through options
#   Enter             - Select current option
#   Ctrl-Space        - Multi-select (mark multiple items)
#   /                 - Start incremental search
#   Ctrl-/            - Toggle preview window
#   F1 / F2           - Switch between completion groups
#   Esc               - Cancel completion
#
# ADVANCED FEATURES:
# -----------------
#   Multiple Selection:
#     rm <TAB>        - Select multiple files with Ctrl-Space
#     git add <TAB>   - Stage multiple files at once
#
#   Continuous Completion:
#     cd /us<TAB>/lo<TAB>/bi<TAB>  - Navigate paths quickly
#
#   Smart Context:
#     $<TAB>          - Show environment variable values
#     ~<TAB>          - Expand user directories
#     kill -<TAB>     - Show signal options
# ============================================================================

# Disable sort when completing `git checkout` for better branch organization
zstyle ':completion:*:git-checkout:*' sort false

# Set descriptions format to enable group support (shows [group name] headers)
zstyle ':completion:*:descriptions' format '[%d]'

# Set list-colors to enable filename colorizing (uses LS_COLORS)
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

# Force zsh not to show completion menu, which allows fzf-tab to capture the unambiguous prefix
zstyle ':completion:*' menu no

# Preview directory contents with eza when completing cd
# Example: cd ~/Doc<TAB> will show contents of Documents folder
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'eza -1 --color=always $realpath 2>/dev/null || ls -la $realpath'

# Switch between groups using F1 and F2
# Example: git <TAB> then F1/F2 to switch between subcommands/files/options
zstyle ':fzf-tab:*' switch-group F1 F2

# Use tmux popup if available (better visual experience in tmux)
if [[ -n $TMUX ]]; then
  zstyle ':fzf-tab:*' fzf-command ftb-tmux-popup
fi

# Give a preview of commandline arguments when completing `kill`
# Example: kill <TAB> shows process command lines
zstyle ':fzf-tab:complete:kill:argument-rest' fzf-preview \
  '[[ $group == "[process ID]" ]] && ps -p $word -o cmd --no-headers -w -w'
zstyle ':fzf-tab:complete:kill:argument-rest' fzf-flags --preview-window=down:3:wrap

# Show systemd unit status
# Example: systemctl status <TAB> shows service status
zstyle ':fzf-tab:complete:systemctl-*:*' fzf-preview 'SYSTEMD_COLORS=1 systemctl status $word'

# Show environment variable values
# Example: echo $<TAB> shows variable values
zstyle ':fzf-tab:complete:(-command-|-parameter-|-brace-parameter-|export|unset|expand):*' \
  fzf-preview 'echo ${(P)word}'

# Show file contents preview (fallback for general file completion)
zstyle ':fzf-tab:complete:*:*' fzf-preview 'less ${(Q)realpath} 2>/dev/null'

# Git status preview for add/diff/restore
# Example: git add <TAB> shows file changes
zstyle ':fzf-tab:complete:git-(add|diff|restore):*' fzf-preview \
  'git diff $word | delta 2>/dev/null || git diff $word'

# Git log preview
# Example: git log <TAB> shows commit history
zstyle ':fzf-tab:complete:git-log:*' fzf-preview \
  'git log --color=always $word'

# Git help preview
# Example: git help <TAB> shows command documentation
zstyle ':fzf-tab:complete:git-help:*' fzf-preview \
  'git help $word | bat -plman --color=always'

# Git show preview with smart context detection
# Example: git show <TAB> shows commits/tags with appropriate preview
zstyle ':fzf-tab:complete:git-show:*' fzf-preview \
  'case "$group" in
  "commit tag") git show --color=always $word ;;
  *) git show --color=always $word | delta ;;
  esac'

# Git checkout preview with context-aware previews
# Example: git checkout <TAB> shows different previews for branches/files/commits
zstyle ':fzf-tab:complete:git-checkout:*' fzf-preview \
  'case "$group" in
  "modified file") git diff $word | delta ;;
  "recent commit object name") git show --color=always $word | delta ;;
  *) git log --color=always $word ;;
  esac'

# Docker command previews
# Example: docker run <TAB> shows image details
zstyle ':fzf-tab:complete:docker-run:*' fzf-preview \
  '[[ $group == "image" ]] && docker image inspect $word'

# Example: docker exec <TAB> shows container details
zstyle ':fzf-tab:complete:docker-exec:*' fzf-preview \
  '[[ $group == "container" ]] && docker container inspect $word'

# SSH host preview - shows SSH config details
# Example: ssh <TAB> shows host configuration
zstyle ':fzf-tab:complete:ssh:*' fzf-preview \
  '[[ $group == "host" ]] && grep -A 5 "^Host $word" ~/.ssh/config 2>/dev/null'

# Man page preview
# Example: man <TAB> shows brief description
zstyle ':fzf-tab:complete:man:*' fzf-preview \
  'man -f $word 2>/dev/null || echo "No manual entry for $word"'

# APT package preview (for Ubuntu/Debian)
# Example: apt install <TAB> shows package info
zstyle ':fzf-tab:complete:apt-(install|show|remove):*' fzf-preview \
  '[[ $group == "package" ]] && apt-cache show $word 2>/dev/null | head -20'

# History command preview
# Example: history <TAB> shows command from history
zstyle ':fzf-tab:complete:history:*' fzf-preview 'echo $word'

# Custom preview window size for different commands
zstyle ':fzf-tab:complete:cd:*' fzf-flags --preview-window=right:50%
zstyle ':fzf-tab:complete:vim:*' fzf-flags --preview-window=right:60%
zstyle ':fzf-tab:complete:git-*:*' fzf-flags --preview-window=right:65%

# Aliases for common fzf-tab behaviors (add to aliases section)
alias fzf-preview-on='zstyle ":fzf-tab:*" fzf-flags --preview-window=right:50%'
alias fzf-preview-off='zstyle ":fzf-tab:*" fzf-flags --preview-window=hidden'
alias fzf-preview-toggle='zstyle ":fzf-tab:*" fzf-flags --preview-window=right:50%:hidden'

ZSHRC_EOF

    # Create functions file
    cat > "$HOME/.zsh_functions" << 'FUNCTIONS_EOF'
# Zsh Functions - Generated by install-shell.sh

# Display a neatly formatted path
function path() {
  echo $PATH | tr ":" "\n" | \
    awk "{ sub(\"/usr\",   \"$fg_no_bold[green]/usr$reset_color\"); \
           sub(\"/bin\",   \"$fg_no_bold[blue]/bin$reset_color\"); \
           sub(\"/opt\",   \"$fg_no_bold[cyan]/opt$reset_color\"); \
           sub(\"/sbin\",  \"$fg_no_bold[magenta]/sbin$reset_color\"); \
           sub(\"/local\", \"$fg_no_bold[yellow]/local$reset_color\"); \
           print }"
}

# Nice mount display
function nicemount() { (echo "DEVICE PATH TYPE FLAGS" && mount | awk '$2="";1') | column -t ; }

# myIP address
function myip() {
  ifconfig lo0 | grep 'inet ' | sed -e 's/:/ /' | awk '{print "lo0       : " $2}'
  ifconfig en0 | grep 'inet ' | sed -e 's/:/ /' | awk '{print "en0 (IPv4): " $2 " " $3 " " $4 " " $5 " " $6}'
  ifconfig en0 | grep 'inet6 ' | sed -e 's/ / /' | awk '{print "en0 (IPv6): " $2 " " $3 " " $4 " " $5 " " $6}'
  ifconfig en1 | grep 'inet ' | sed -e 's/:/ /' | awk '{print "en1 (IPv4): " $2 " " $3 " " $4 " " $5 " " $6}'
  ifconfig en1 | grep 'inet6 ' | sed -e 's/ / /' | awk '{print "en1 (IPv6): " $2 " " $3 " " $4 " " $5 " " $6}'
}
FUNCTIONS_EOF

    # Add function sourcing to .zshrc
    echo "" >> "$HOME/.zshrc"
    echo "# Load custom functions" >> "$HOME/.zshrc"
    echo "[ -f ~/.zsh_functions ] && source ~/.zsh_functions" >> "$HOME/.zshrc"

    print_success "Zsh configuration created"
}

# Install FZF
install_fzf() {
    print_status "Installing FZF..."

    if [[ ! -d "$HOME/.fzf" ]]; then
        git clone --depth 1 https://github.com/junegunn/fzf.git "$HOME/.fzf"
        "$HOME/.fzf/install" --all --no-bash --no-fish
    else
        print_status "FZF is already installed"
    fi

    print_success "FZF installed"
}

# Install Z directory jumping script
install_z_script() {
    print_status "Installing Z directory jumping script..."

    # Create the z.sh script with embedded content
    cat > "$HOME/.z.sh" << 'Z_SCRIPT_EOF'
# Copyright (c) 2009 rupa deadwyler. Licensed under the WTFPL license, Version 2

# maintains a jump-list of the directories you actually use
#
# INSTALL:
#     * put something like this in your .bashrc/.zshrc:
#         . /path/to/z.sh
#     * cd around for a while to build up the db
#     * PROFIT!!
#     * optionally:
#         set $_Z_CMD in .bashrc/.zshrc to change the command (default z).
#         set $_Z_DATA in .bashrc/.zshrc to change the datafile (default ~/.z).
#         set $_Z_NO_RESOLVE_SYMLINKS to prevent symlink resolution.
#         set $_Z_NO_PROMPT_COMMAND if you're handling PROMPT_COMMAND yourself.
#         set $_Z_EXCLUDE_DIRS to an array of directories to exclude.
#         set $_Z_OWNER to your username if you want use z while sudo with $HOME kept
#
# USE:
#     * z foo     # cd to most frecent dir matching foo
#     * z foo bar # cd to most frecent dir matching foo and bar
#     * z -r foo  # cd to highest ranked dir matching foo
#     * z -t foo  # cd to most recently accessed dir matching foo
#     * z -l foo  # list matches instead of cd
#     * z -c foo  # restrict matches to subdirs of $PWD

[ -d "${_Z_DATA:-$HOME/.z}" ] && {
    echo "ERROR: z.sh's datafile (${_Z_DATA:-$HOME/.z}) is a directory."
}

_z() {

    local datafile="${_Z_DATA:-$HOME/.z}"

    # if symlink, dereference
    [ -h "$datafile" ] && datafile=$(readlink "$datafile")

    # bail if we don't own ~/.z and $_Z_OWNER not set
    [ -z "$_Z_OWNER" -a -f "$datafile" -a ! -O "$datafile" ] && return

    _z_dirs () {
        while read line; do
            # only count directories
            [ -d "${line%%\|*}" ] && echo $line
        done < "$datafile"
        return 0
    }

    # add entries
    if [ "$1" = "--add" ]; then
        shift

        # $HOME isn't worth matching
        [ "$*" = "$HOME" ] && return

        # don't track excluded directory trees
        local exclude
        for exclude in "${_Z_EXCLUDE_DIRS[@]}"; do
            case "$*" in "$exclude*") return;; esac
        done

        # maintain the data file
        local tempfile="$datafile.$RANDOM"
        awk < <(_z_dirs 2>/dev/null) -v path="$*" -v now="$(date +%s)" -F"|" '
            BEGIN {
                rank[path] = 1
                time[path] = now
            }
            $2 >= 1 {
                # drop ranks below 1
                if( $1 == path ) {
                    rank[$1] = $2 + 1
                    time[$1] = now
                } else {
                    rank[$1] = $2
                    time[$1] = $3
                }
                count += $2
            }
            END {
                if( count > 9000 ) {
                    # aging
                    for( x in rank ) print x "|" 0.99*rank[x] "|" time[x]
                } else for( x in rank ) print x "|" rank[x] "|" time[x]
            }
        ' 2>/dev/null >| "$tempfile"
        # do our best to avoid clobbering the datafile in a race condition.
        if [ $? -ne 0 -a -f "$datafile" ]; then
            env rm -f "$tempfile"
        else
            [ "$_Z_OWNER" ] && chown $_Z_OWNER:$(id -ng $_Z_OWNER) "$tempfile"
            env mv -f "$tempfile" "$datafile" || env rm -f "$tempfile"
        fi

    # tab completion
    elif [ "$1" = "--complete" -a -s "$datafile" ]; then
        while read line; do
            [ -d "${line%%\|*}" ] && echo $line
        done < "$datafile" | awk -v q="$2" -F"|" '
            BEGIN {
                if( q == tolower(q) ) imatch = 1
                q = substr(q, 3)
                gsub(" ", ".*", q)
            }
            {
                if( imatch ) {
                    if( tolower($1) ~ tolower(q) ) print $1
                } else if( $1 ~ q ) print $1
            }
        ' 2>/dev/null

    else
        # list/go
        while [ "$1" ]; do case "$1" in
            --) while [ "$1" ]; do shift; local fnd="$fnd${fnd:+ }$1";done;;
            -*) local opt=${1:1}; while [ "$opt" ]; do case ${opt:0:1} in
                    c) local fnd="^$PWD $fnd";;
                    e) local echo=echo;;
                    h) echo "${_Z_CMD:-z} [-cehlrtx] args" >&2; return;;
                    l) local list=1;;
                    r) local typ="rank";;
                    t) local typ="recent";;
                    x) sed -i -e "\:^${PWD}|.*:d" "$datafile";;
                esac; opt=${opt:1}; done;;
             *) local fnd="$fnd${fnd:+ }$1";;
        esac; local last=$1; [ "$#" -gt 0 ] && shift; done
        [ "$fnd" -a "$fnd" != "^$PWD " ] || local list=1

        # if we hit enter on a completion just go there
        case "$last" in
            # completions will always start with /
            /*) [ -z "$list" -a -d "$last" ] && builtin cd "$last" && return;;
        esac

        # no file yet
        [ -f "$datafile" ] || return

        local cd
        cd="$( < <( _z_dirs ) awk -v t="$(date +%s)" -v list="$list" -v typ="$typ" -v q="$fnd" -F"|" '
            function frecent(rank, time) {
                # relate frequency and time
                dx = t - time
                if( dx < 3600 ) return rank * 4
                if( dx < 86400 ) return rank * 2
                if( dx < 604800 ) return rank / 2
                return rank / 4
            }
            function output(matches, best_match, common) {
                # list or return the desired directory
                if( list ) {
                    cmd = "sort -n >&2"
                    for( x in matches ) {
                        if( matches[x] ) {
                            printf "%-10s %s\n", matches[x], x | cmd
                        }
                    }
                    if( common ) {
                        printf "%-10s %s\n", "common:", common > "/dev/stderr"
                    }
                } else {
                    if( common ) best_match = common
                    print best_match
                }
            }
            function common(matches) {
                # find the common root of a list of matches, if it exists
                for( x in matches ) {
                    if( matches[x] && (!short || length(x) < length(short)) ) {
                        short = x
                    }
                }
                if( short == "/" ) return
                for( x in matches ) if( matches[x] && index(x, short) != 1 ) {
                    return
                }
                return short
            }
            BEGIN {
                gsub(" ", ".*", q)
                hi_rank = ihi_rank = -9999999999
            }
            {
                if( typ == "rank" ) {
                    rank = $2
                } else if( typ == "recent" ) {
                    rank = $3 - t
                } else rank = frecent($2, $3)
                if( $1 ~ q ) {
                    matches[$1] = rank
                } else if( tolower($1) ~ tolower(q) ) imatches[$1] = rank
                if( matches[$1] && matches[$1] > hi_rank ) {
                    best_match = $1
                    hi_rank = matches[$1]
                } else if( imatches[$1] && imatches[$1] > ihi_rank ) {
                    ibest_match = $1
                    ihi_rank = imatches[$1]
                }
            }
            END {
                # prefer case sensitive
                if( best_match ) {
                    output(matches, best_match, common(matches))
                } else if( ibest_match ) {
                    output(imatches, ibest_match, common(imatches))
                }
            }
        ')"

        [ $? -eq 0 ] && [ "$cd" ] && {
          if [ "$echo" ]; then echo "$cd"; else builtin cd "$cd"; fi
        }
    fi
}

alias ${_Z_CMD:-z}='_z 2>&1'

[ "$_Z_NO_RESOLVE_SYMLINKS" ] || _Z_RESOLVE_SYMLINKS="-P"

if type compctl >/dev/null 2>&1; then
    # zsh
    [ "$_Z_NO_PROMPT_COMMAND" ] || {
        # populate directory list, avoid clobbering any other precmds.
        if [ "$_Z_NO_RESOLVE_SYMLINKS" ]; then
            _z_precmd() {
                (_z --add "${PWD:a}" &)
            }
        else
            _z_precmd() {
                (_z --add "${PWD:A}" &)
            }
        fi
        [[ -n "${precmd_functions[(r)_z_precmd]}" ]] || {
            precmd_functions[$(($#precmd_functions+1))]=_z_precmd
        }
    }
    _z_zsh_tab_completion() {
        # tab completion
        local compl
        read -l compl
        reply=(${(f)"$(_z --complete "$compl")"})
    }
    compctl -U -K _z_zsh_tab_completion _z
elif type complete >/dev/null 2>&1; then
    # bash
    # tab completion
    complete -o filenames -C '_z --complete "$COMP_LINE"' ${_Z_CMD:-z}
    [ "$_Z_NO_PROMPT_COMMAND" ] || {
        # populate directory list. avoid clobbering other PROMPT_COMMANDs.
        grep "_z --add" <<< "$PROMPT_COMMAND" >/dev/null || {
            PROMPT_COMMAND="$PROMPT_COMMAND"$'\n''(_z --add "$(command pwd '$_Z_RESOLVE_SYMLINKS' 2>/dev/null)" 2>/dev/null &);'
        }
    }
fi
Z_SCRIPT_EOF

    print_success "Z directory jumping script installed"
}

# Install additional shell tools
install_shell_tools() {
    print_status "Installing additional shell tools..."

    case "$DOTFILES_OS" in
        linux)
            # Install from apt
            sudo apt-get update
            sudo apt-get install -y \
                bat \
                fd-find \
                ripgrep \
                htop \
                ncdu \
                tree \
                jq \
                tldr \
                curl \
                wget

            # Install eza (modern replacement for ls)
            # Check if eza is available in the repos, otherwise install from GitHub
            if ! command -v eza &> /dev/null; then
                print_status "Installing eza from GitHub release..."
                EZA_VERSION=$(curl -s "https://api.github.com/repos/eza-community/eza/releases/latest" | grep '"tag_name":' | sed -E 's/.*"v([^"]+)".*/\1/')
                curl -Lo /tmp/eza.tar.gz "https://github.com/eza-community/eza/releases/latest/download/eza_x86_64-unknown-linux-gnu.tar.gz"
                sudo tar -xzf /tmp/eza.tar.gz -C /usr/local/bin
                rm /tmp/eza.tar.gz
            fi

            # Install delta (git diff viewer) if not present
            if ! command -v delta &> /dev/null; then
                print_status "Installing delta from GitHub release..."
                DELTA_VERSION=$(curl -s "https://api.github.com/repos/dandavison/delta/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
                curl -Lo /tmp/delta.deb "https://github.com/dandavison/delta/releases/latest/download/git-delta_${DELTA_VERSION}_amd64.deb"
                sudo dpkg -i /tmp/delta.deb
                rm /tmp/delta.deb
            fi

            # Create symlinks for different names
            sudo ln -sf /usr/bin/fdfind /usr/local/bin/fd
            sudo ln -sf /usr/bin/batcat /usr/local/bin/bat
            ;;
        macos)
            brew install \
                bat \
                fd \
                ripgrep \
                htop \
                ncdu \
                tree \
                jq \
                tldr \
                eza \
                zoxide \
                starship
            ;;
    esac

    print_success "Shell tools installed"
}

# Install fonts
install_fonts() {
    print_status "Installing Nerd Fonts..."

    # Create fonts directory
    case "$DOTFILES_OS" in
        linux)
            FONT_DIR="$HOME/.local/share/fonts"
            ;;
        macos)
            FONT_DIR="$HOME/Library/Fonts"
            ;;
    esac

    mkdir -p "$FONT_DIR"

    # Download and install popular Nerd Fonts
    local fonts=(
        # "FiraCode"
        # "JetBrainsMono"
        # "Hack"
        "SourceCodePro"
    )

    for font in "${fonts[@]}"; do
        print_status "Installing $font Nerd Font..."

        # Download font
        local font_url="https://github.com/ryanoasis/nerd-fonts/releases/latest/download/${font}.zip"
        if curl -L -o "/tmp/${font}.zip" "$font_url"; then
            # Extract to font directory
            unzip -q -o "/tmp/${font}.zip" -d "$FONT_DIR"
            rm "/tmp/${font}.zip"
            print_success "$font Nerd Font installed"
        else
            print_warning "Failed to download $font Nerd Font"
        fi
    done

    # Update font cache on Linux
    if [[ "$DOTFILES_OS" == "linux" ]]; then
        fc-cache -fv
    fi

    print_success "Fonts installed"
}

# Change default shell to Zsh
# Returns 0 if shell was changed, 1 otherwise
change_shell_to_zsh() {
    print_status "Would you like to change your default shell to Zsh? (Y/n)"
    read -r response
    if [[ ! "$response" =~ ^([nN][oO]|[nN])$ ]]; then
        if command -v zsh &> /dev/null; then
            local zsh_path="$(command -v zsh)"

            # Add zsh to /etc/shells if not already there
            if ! grep -q "$zsh_path" /etc/shells; then
                echo "$zsh_path" | sudo tee -a /etc/shells
            fi

            # Change shell
            chsh -s "$zsh_path"
            print_success "Default shell changed to Zsh"
            # Return 0 to indicate shell was changed
            return 0
        else
            print_error "Zsh not found. Please install it first."
            return 1
        fi
    fi
    # Return 1 to indicate shell was not changed
    return 1
}

# Main installation flow
main() {
    print_status "Shell Configuration Installation"
    echo

    # Track if shell was changed
    local shell_changed=0

    # Install shells and tools
    install_zsh
    install_oh_my_zsh
    install_zsh_plugins
    install_powerlevel10k
    configure_zsh

    # Install additional tools
    install_fzf
    install_z_script
    install_shell_tools
    install_fonts

    # Change default shell (captures return value)
    if change_shell_to_zsh; then
        shell_changed=1
    fi

    print_success "Shell configuration completed!"
    echo
    print_status "Next steps:"

    # Only show logout reminder if shell was actually changed
    if [[ $shell_changed -eq 1 ]]; then
        echo "  1. Log out and back in to use Zsh as default shell"
        echo "  2. Run 'p10k configure' to set up Powerlevel10k theme"
        echo "  3. Install tmux plugins: prefix + I (Ctrl-a then Shift-i)"
    else
        echo "  1. Run 'p10k configure' to set up Powerlevel10k theme"
        echo "  2. Install tmux plugins: prefix + I (Ctrl-a then Shift-i)"
    fi

    # Additional helpful reminders
    echo ""
    print_status "fzf-tab is configured! Try these examples:"
    echo "  - cd <TAB> to browse directories with preview"
    echo "  - git checkout <TAB> to switch branches"
    echo "  - Use Ctrl-Space for multi-selection"
    echo "  - Press F1/F2 to switch between groups"
}

# Run if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
